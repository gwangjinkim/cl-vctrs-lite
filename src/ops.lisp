;;;; src/ops.lisp

(in-package #:cl-vctrs-lite)

(declaim (inline %fmt-type))
(defun %fmt-type (tag)
  (string-downcase (format nil "~s" tag)))

(declaim (inline %numeric-type-p))
(defun %numeric-type-p (tag)
  (or (eq tag :int) (eq tag :double)))

(defun %prep-numeric (name a b)
  (multiple-value-bind (va vb n) (recycle2 a b)
    (let* ((ta (col-type va))
           (tb (col-type vb))
           (ct (common-type ta tb)))
      (unless (or (%numeric-type-p ct)
                  (and (eq ta :any) (eq tb :any)))
        (%simple-error "~a unsupported operand types ~a and ~a"
                       name (%fmt-type ta) (%fmt-type tb)))
      (values va vb n))))

(defun %arith-op (name a b fn &key (check-div-zero nil))
  (multiple-value-bind (va vb n) (%prep-numeric name a b)
    (let ((out (make-array n)))
      (declare (optimize (speed 3) (safety 0) (debug 0)))
      (dotimes (i n out)
        (let ((x (aref va i))
              (y (aref vb i)))
          (if (or (na-p x) (na-p y))
              (setf (aref out i) *na*)
              (let* ((dx (coerce x 'double-float))
                     (dy (coerce y 'double-float)))
                (when (and check-div-zero (zerop dy))
                  (%simple-error "v/: division by zero"))
                (setf (aref out i) (funcall fn dx dy)))))))))

(defun v+ (a b) (%arith-op "v+:" a b #'+))
(defun v- (a b) (%arith-op "v-:" a b #'-))
(defun v* (a b) (%arith-op "v*:" a b #'*))
(defun v/ (a b) (%arith-op "v/:" a b #'/ :check-div-zero t))

(defun v= (a b)
  (multiple-value-bind (va vb n) (recycle2 a b)
    (let* ((ta (col-type va))
           (tb (col-type vb))
           (ct (common-type ta tb))
           (out (make-array n)))
      (declare (optimize (speed 3) (safety 0) (debug 0)))
      (cond
        ((%numeric-type-p ct)
         (dotimes (i n out)
           (let ((x (aref va i)) (y (aref vb i)))
             (if (or (na-p x) (na-p y))
                 (setf (aref out i) *na*)
                 (setf (aref out i)
                       (if (= (coerce x 'double-float)
                              (coerce y 'double-float)) t nil))))))
        ((and (eq ta :string) (eq tb :string))
         (dotimes (i n out)
           (let ((x (aref va i)) (y (aref vb i)))
             (if (or (na-p x) (na-p y))
                 (setf (aref out i) *na*)
                 (setf (aref out i) (if (string= x y) t nil))))))
        ((and (eq ta :bool) (eq tb :bool))
         (dotimes (i n out)
           (let ((x (aref va i)) (y (aref vb i)))
             (if (or (na-p x) (na-p y))
                 (setf (aref out i) *na*)
                 (setf (aref out i) (if (eql x y) t nil))))))
        ((and (eq ta :any) (eq tb :any))
         ;; All NA: result all NA
         (dotimes (i n) (setf (aref out i) *na*))
         out)
        (t
         (%simple-error "v=: unsupported operand types ~a and ~a"
                        (%fmt-type ta) (%fmt-type tb)))))))

(defun %order-op (name a b num-fn str-fn)
  (multiple-value-bind (va vb n) (recycle2 a b)
    (let* ((ta (col-type va))
           (tb (col-type vb))
           (ct (common-type ta tb))
           (out (make-array n)))
      (declare (optimize (speed 3) (safety 0) (debug 0)))
      (cond
        ((%numeric-type-p ct)
         (dotimes (i n out)
           (let ((x (aref va i)) (y (aref vb i)))
             (if (or (na-p x) (na-p y))
                 (setf (aref out i) *na*)
                 (setf (aref out i)
                       (if (funcall num-fn (coerce x 'double-float)
                                            (coerce y 'double-float))
                           t nil))))))
        ((and (eq ta :string) (eq tb :string))
         (dotimes (i n out)
           (let ((x (aref va i)) (y (aref vb i)))
             (if (or (na-p x) (na-p y))
                 (setf (aref out i) *na*)
                 (setf (aref out i) (if (funcall str-fn x y) t nil))))))
        ((and (eq ta :any) (eq tb :any))
          (dotimes (i n) (setf (aref out i) *na*))
          out)
        (t
         (%simple-error "~a unsupported operand types ~a and ~a"
                        name (%fmt-type ta) (%fmt-type tb)))))))

(defun v< (a b) (%order-op "v<:" a b #'< #'string<))
(defun v> (a b) (%order-op "v>:" a b #'> #'string>))
(defun v<= (a b) (%order-op "v<=:" a b #'<= #'string<=))
(defun v>= (a b) (%order-op "v>=:" a b #'>= #'string>=))
