;;;; src/ops.lisp

(in-package #:cl-vctrs-lite)

(declaim (inline %fmt-type))
(defun %fmt-type (tag)
  (string-downcase (format nil "~s" tag)))

(declaim (inline %numeric-type-p))
(defun %numeric-type-p (tag)
  (or (eq tag :int) (eq tag :double)))

(defun %prep-numeric (name a b)
  (multiple-value-bind (va vb n) (recycle2 a b)
    (let* ((ta (col-type va))
           (tb (col-type vb))
           (ct (common-type ta tb)))
      (unless (or (%numeric-type-p ct)
                  (and (eq ta :any) (eq tb :any)))
        (%simple-error "~a unsupported operand types ~a and ~a"
                       name (%fmt-type ta) (%fmt-type tb)))
      (values va vb n))))

;; Internal numeric buffers: double array + NA mask
(declaim (inline %build-num-buf))
(defun %build-num-buf (v n)
  (let ((data (make-array n :element-type 'double-float))
        (mask (make-array n :element-type 'bit)))
    (declare (optimize (speed 3) (safety 0) (debug 0))
             (type (simple-array double-float (*)) data)
             (type simple-bit-vector mask))
    (dotimes (i n)
      (let ((x (aref v i)))
        (if (na-p x)
            (progn
              (setf (sbit mask i) 1)
              (setf (aref data i) 0.0d0))
            (progn
              (setf (sbit mask i) 0)
              (setf (aref data i) (coerce x 'double-float))))))
    (values data mask)))

(declaim (inline %emit-num-result))
(defun %emit-num-result (data mask)
  (let* ((n (length data))
         (out (make-array n)))
    (declare (optimize (speed 3) (safety 0) (debug 0))
             (type (simple-array double-float (*)) data)
             (type simple-bit-vector mask))
    (dotimes (i n out)
      (if (= (sbit mask i) 1)
          (setf (aref out i) *na*)
          (setf (aref out i) (aref data i))))))

(defun %arith-op (name a b fn &key (check-div-zero nil))
  (multiple-value-bind (va vb n) (%prep-numeric name a b)
    (multiple-value-bind (da ma) (%build-num-buf va n)
      (multiple-value-bind (db mb) (%build-num-buf vb n)
        (let ((do (make-array n :element-type 'double-float))
              (mo (make-array n :element-type 'bit)))
          (declare (optimize (speed 3) (safety 0) (debug 0))
                   (type (simple-array double-float (*)) da db do)
                   (type simple-bit-vector ma mb mo))
          (dotimes (i n)
            (let ((na (sbit ma i))
                  (nb (sbit mb i)))
              (if (or (= na 1) (= nb 1))
                  (progn (setf (sbit mo i) 1)
                         (setf (aref do i) 0.0d0))
                  (let ((dx (aref da i))
                        (dy (aref db i)))
                    (when (and check-div-zero (zerop dy))
                      (%simple-error "v/: division by zero"))
                    (setf (sbit mo i) 0)
                    (setf (aref do i) (funcall fn dx dy))))))
          (%emit-num-result do mo))))))

(defun v+ (a b) (%arith-op "v+:" a b #'+))
(defun v- (a b) (%arith-op "v-:" a b #'-))
(defun v* (a b) (%arith-op "v*:" a b #'*))
(defun v/ (a b) (%arith-op "v/:" a b #'/ :check-div-zero t))

(defun v= (a b)
  (multiple-value-bind (va vb n) (recycle2 a b)
    (let* ((ta (col-type va))
           (tb (col-type vb))
           (ct (common-type ta tb))
           (out (make-array n)))
      (declare (optimize (speed 3) (safety 0) (debug 0)))
      (cond
        ((%numeric-type-p ct)
         (multiple-value-bind (da ma) (%build-num-buf va n)
           (multiple-value-bind (db mb) (%build-num-buf vb n)
             (declare (type (simple-array double-float (*)) da db)
                      (type simple-bit-vector ma mb))
             (dotimes (i n out)
               (let ((na (sbit ma i))
                     (nb (sbit mb i)))
                 (if (or (= na 1) (= nb 1))
                     (setf (aref out i) *na*)
                     (setf (aref out i) (if (= (aref da i) (aref db i)) t nil))))))))
        ((and (eq ta :string) (eq tb :string))
         (dotimes (i n out)
           (let ((x (aref va i)) (y (aref vb i)))
             (if (or (na-p x) (na-p y))
                 (setf (aref out i) *na*)
                 (setf (aref out i) (if (string= x y) t nil))))))
        ((and (eq ta :bool) (eq tb :bool))
         (dotimes (i n out)
           (let ((x (aref va i)) (y (aref vb i)))
             (if (or (na-p x) (na-p y))
                 (setf (aref out i) *na*)
                 (setf (aref out i) (if (eql x y) t nil))))))
        ((and (eq ta :any) (eq tb :any))
         ;; All NA: result all NA
         (dotimes (i n) (setf (aref out i) *na*))
         out)
        (t
         (%simple-error "v=: unsupported operand types ~a and ~a"
                        (%fmt-type ta) (%fmt-type tb)))))))

(defun %order-op (name a b num-fn str-fn)
  (multiple-value-bind (va vb n) (recycle2 a b)
    (let* ((ta (col-type va))
           (tb (col-type vb))
           (ct (common-type ta tb))
           (out (make-array n)))
      (declare (optimize (speed 3) (safety 0) (debug 0)))
      (cond
        ((%numeric-type-p ct)
         (multiple-value-bind (da ma) (%build-num-buf va n)
           (multiple-value-bind (db mb) (%build-num-buf vb n)
             (declare (type (simple-array double-float (*)) da db)
                      (type simple-bit-vector ma mb))
             (dotimes (i n out)
               (let ((na (sbit ma i))
                     (nb (sbit mb i)))
                 (if (or (= na 1) (= nb 1))
                     (setf (aref out i) *na*)
                     (setf (aref out i)
                           (if (funcall num-fn (aref da i) (aref db i)) t nil))))))))
        ((and (eq ta :string) (eq tb :string))
         (dotimes (i n out)
           (let ((x (aref va i)) (y (aref vb i)))
             (if (or (na-p x) (na-p y))
                 (setf (aref out i) *na*)
                 (setf (aref out i) (if (funcall str-fn x y) t nil))))))
        ((and (eq ta :any) (eq tb :any))
          (dotimes (i n) (setf (aref out i) *na*))
          out)
        (t
         (%simple-error "~a unsupported operand types ~a and ~a"
                        name (%fmt-type ta) (%fmt-type tb)))))))

(defun v< (a b) (%order-op "v<:" a b #'< #'string<))
(defun v> (a b) (%order-op "v>:" a b #'> #'string>))
(defun v<= (a b) (%order-op "v<=:" a b #'<= #'string<=))
(defun v>= (a b) (%order-op "v>=:" a b #'>= #'string>=))
